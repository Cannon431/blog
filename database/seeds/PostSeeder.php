<?php

use Illuminate\Database\Seeder;
use Illuminate\Support\Carbon;

class PostSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table('posts')->truncate();

        $posts = [
            [
                'category_id' => 1,
                'author_id' => 1,
                'title' => 'Google Chrome научился блокировать автовоспроизведение видеоконтента',
                'image' => 'blog-2.jpg',
                'text' => '<p>В Google Chrome <a href="https://techcrunch.com/2018/05/03/chrome-now-mutes-annoying-autoplays-based-on-your-past-behavior/" data-wpel-link="external" target="_blank" rel="nofollow noopener noreferrer">появилась</a> функция автоматической блокировки воспроизведения видеоконтента, которая работает, основываясь на поведении пользователя. Компания уже <a href="https://sites.google.com/a/chromium.org/dev/audio-video/autoplay" data-wpel-link="external" target="_blank" rel="nofollow noopener noreferrer">внедрила</a> подобную функцию в мобильный браузер, теперь она есть и в десктопной версии.</p><h3>Как это работает?</h3><p>По словам представителей компании, большинство пользователей выключает звук или закрывает вкладку с автоматически воспроизводимым видео в течение первых шести секунд. Основываясь на этих измерениях, браузер анализирует пользовательскую активность и запоминает, на каких сайтах следует выключать мгновенный запуск. Для новых или не авторизованных пользователей Chrome будет автоматически блокировать видео на первой тысяче сайтов, исходя из «правила шести секунд».</p><p>В Google утверждают, что после анализа действий пользователя и обучения браузер сможет блокировать около половины такого контента.</p><p>Напомним, что в апреле 2018 года компания <a href="https://tproger.ru/news/google-chrome-66-release/" data-wpel-link="internal" rel="follow">представила</a> релиз Google Chrome 66, который добавил функцию ручной блокировки звука, а также повысил безопасность.',
                'views' => mt_rand(472, 4840),
                'description' => 'Вы когда-нибудь хотели передавать IP-трафик через мессенджер? Хотели проверить, на что способен Telegram? Что значит «нет»? А надо! Ловите Teletun и наслаждайтесь!'
            ],

            [
                'category_id' => 2,
                'author_id' => 2,
                'title' => 'Представлен релиз движка Unity 2018.1',
                'image' => 'blog-1.jpg',
                'text' => '<p>В Google Chrome <a href="https://techcrunch.com/2018/05/03/chrome-now-mutes-annoying-autoplays-based-on-your-past-behavior/" data-wpel-link="external" target="_blank" rel="nofollow noopener noreferrer">появилась</a> функция автоматической блокировки воспроизведения видеоконтента, которая работает, основываясь на поведении пользователя. Компания уже <a href="https://sites.google.com/a/chromium.org/dev/audio-video/autoplay" data-wpel-link="external" target="_blank" rel="nofollow noopener noreferrer">внедрила</a> подобную функцию в мобильный браузер, теперь она есть и в десктопной версии.</p><h3>Как это работает?</h3><p>По словам представителей компании, большинство пользователей выключает звук или закрывает вкладку с автоматически воспроизводимым видео в течение первых шести секунд. Основываясь на этих измерениях, браузер анализирует пользовательскую активность и запоминает, на каких сайтах следует выключать мгновенный запуск. Для новых или не авторизованных пользователей Chrome будет автоматически блокировать видео на первой тысяче сайтов, исходя из «правила шести секунд».</p><p>В Google утверждают, что после анализа действий пользователя и обучения браузер сможет блокировать около половины такого контента.</p><p>Напомним, что в апреле 2018 года компания <a href="https://tproger.ru/news/google-chrome-66-release/" data-wpel-link="internal" rel="follow">представила</a> релиз Google Chrome 66, который добавил функцию ручной блокировки звука, а также повысил безопасность.',
                'views' => mt_rand(138, 1023),
                'description' => 'Мы — стартап «Absolute», выиграли Microsoft Imagine Cup Central Asia. Наши математические открытия помогли нам создать улучшенную криптографическую систему обработки данных.'
            ],

            [
                'category_id' => 5,
                'author_id' => 2,
                'title' => 'PHP vs Node.js',
                'image' => 'blog-3.jpg',
                'text' => '<h4>«10 раундов боксеров разных весовых категорий»</h4><br/>
<img src="https://habrastorage.org/files/8cb/efc/156/8cbefc1560344b4890a65668be7733b3.jpg" align="left"/>Одним прекрасным днем Крэг Баклэр (Craig Buckler) на сайте SitePoint.com опубликловал сравнительный анализ PHP и NodeJS под названием «10 раундов», чтобы определить кто является абсолютным чемпионом. Однако, в это же время он отметил, что такой анализ является несколько спорным. Поэтому, для некоторого развлечения, он пригласил двух судей, которые внесли бы свою лепту в этот боксерский поединок. Он попросил Бруно Шкворца (Bruno Škvorc, редактор колонки PHP на сайте SitePoint.com) и Джеймса Хиббарда (James Hibbard, редактор колонки JavaScript на сайте SitePoint.com) прокомментировать каждый из раундов, удар за ударом — оценка.<br/>
<a name="habracut"></a><br/>
<h4>Введение</h4><br/>
Web-программирование стремительно развивается, и перед back-end разработчиками встает вопрос выбора между устоявшимися тяжеловесами Java, C, Perl и современными веб-ориентированными языками, такими как, Ruby, Clojure, Go. Ваш выбор имеет огромное значение, накладывая свой отпечаток на работу приложения. <br/>
<br/>
Но какой сделать выбор для веб-разработки?<br/>
<br/>
Не хочеться затевать холивар, но все же мы будем сегодня говорить о PHP и NodeJS:<br/>
<br/>
<ul>
<li> PHP — был создан в 1994 году Расмусом Лердфордом (Rasmus Lerdorf). Он создал программную оболочку (интерпретатор), которая устанавливается в качестве модуля для веб-сервера Apache или Nginx. Изначально разрабатывался как препроцессор гипертекстовых страниц, поэтому PHP может быть легко интегрирован в HTML код, однако, такой подход сейчас не является хорошей практикой, но все же для новичков такой подход был очевиден. Это способствовало популярности языка, поэтому 80% сайтов в интернете написаны на PHP, они же, в частности, работают под управлением WordPress CMS (20% сайтов в интернете).</li>
<li>Node.js — был создан в 2009 году Райаном Далем (Ryan Dahl). Он создал программную платформу, основанную на JavaScript движке V8 от Google. Необычно то, что платформа имеет встроенные библиотеки для обработки запросов и ответов, тем самым вам не нужно использовать сторонний веб-сервер и какие-либо другие зависимости. Node.js набирает обороты и он используется такими компаниями, как Microsoft, Yahoo, LinkedIn и PayPal.</li>
</ul><br/>
<h4>Почему не говорим о C#, Java, Ruby, Python, Perl, Erlang, C++, Go, Dart, Scala, Haskell, и других?</h4><br/>
Стали бы вы читать статью обо всем и вся, вам нужна энциклопедия? Поэтому мы огранили и сужили круг до двух знаменитых потому, что:<br/>
<br/>
1. PHP и Node.js веб-ориентированны, у обоих открытый исходных код, они направлены, исключительно, на веб-разработку<br/>
2. PHP давний язык, однако, Node.js в нашем случае является выскочкой, который набирает обороты по популярности, поэтому php-разработчику стоит задаться вопросом. А стоит ли менять технологию?<br/>
3. Многие разработчики программируют с далеких 90х на PHP и JavaScript и переходить на другие языки программирования не все хотят, ибо не отдают им должное.<br/>
<br/>
<h4>Правила</h4><br/>
Боксер в правом углу — PHP, боксер в левом — Node.js. Абсолютным победителем будет та технология, которая победит по количеству раундов.<br/>
<br/>
<h4>Первый раунд: быстрый старт</h4><br/>
В этом раунде мы определяем, как быстро мы можем написать «Hello, world» страницу на том или ином языке программирования, в это время мы включаем время потраченное на настройку сервера.<br/>
<br/>
Подготавливаем среду:<br/>
<br/>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Ibpil1UCASM?feature=oembed" frameborder="0" allowfullscreen></iframe><br/>
<br/>
1) Как быстро вы можете построить «Hello World» веб-страницу на PHP:<br/>
<br/>
<pre><code class="php">&lt;?php
	echo \'Hello World!\';
?&gt;
</code></pre><br/>
Этот код может быть написан где угодно, как правило, код пишут в файлах, оканчивающихся на расширение <i>.php</i>. Если вы написали этот код в файле <i>index.php</i> и запустили на локальном сервере через порт 8000 (на своем компьютере, а не на реальном хостинге), то его отображение будет доступно по адресу: <br/>
<br/>
<pre><code>http://localhost:8000
</code></pre>.<br/>
Однако, используя готовый интерпретатор PHP со встроенным сервером довольно ненадежное занятие. Лучше использовать готовые решения, сборки Apache — XAMPP или виртуальные OS (Vagrant). Кстати, свой файл вы сможете загрузить на любой хостинг интернета.<br/>
<br/>
2) Установить платформу Node.js проще простого, если вы работаете на unix-подобных системах, вы сможете это сделать и при помощи менеджеров пакетов. Давайте создадим страницу index.js:<br/>
<br/>
<pre><code class="javascript">const http = require(\'http\');
const hostname = \'localhost\';
const port = 8000;

http.createServer((req, res) =&gt; {
  res.writeHead(200, { \'Content-Type\': \'text/plain\' });
  res.end(\'Hello World\n\');
}).listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre><br/>
Мы повторили аналогичные действия, код на JavaScript, как правило, пишут в файлах, оканчивающихся на расширение <i>.js</i>. Если вы написали этот код в файле <i>index.js</i> и запустили на локальном сервере через порт 8000 (на своем компьютере, а не на реальном хостинге), то его отображение также будет доступно по адресу (при условии, что php теперь работает на другом порту): <br/>
<br/>
<pre><code>http://localhost:8000
</code></pre><br/>
Теперь давайте оценим код, даже если вы хорошо знаете клиентский JavaScript, вам придется думать и разбираться с тем, что же здесь написано. Вы должны понимать замыкания и callback-функции, промисы, программирование на стороне Node.js требует некоторой сноровки.<br/>
<br/>
PHP концептуально проще и выигрывает этот раунд. Хотя PHP имеет несколько программных зависимостей, однако PHP менее сложный для изучения.<br/>
<br/>
<h4>Оценка судей — <b>PHP 1:0 Node.js</b></h4><br/>
<ul>
<li>Бруно: PHP выигрывает из-за низкого порога вхождения. Тут скорее вопрос восприятия. На экране они отображаются одинаково и существенного отличия у них нет. Фактически синтаксис гораздо проще для новичков программирования. </li>
<li>Джеймс: При разработке на локальной машине, я не вижу разницы между ними. Чтобы запустить скрипт в браузере, вам необходимо иметь веб-сервер и терминал. Чтобы на Node.js делать что-то серьезное, нужно устанавливать дополнительные модули, например, express (фреймворк для веб-приложений). Однако, концептуально PHP — проще.<br/>
</li>
</ul><br/>
<h4>Второй раунд: помощь и поддержка</h4><br/>
На самом деле вы никуда не уедете на своих знаниях без изучения каких-либо курсов, современных практик, чтобы развиваться, вам нужно задавать вопросы на форумах, таких как — StackOverflow. PHP выигрывает этот раунд легко, он имеет большое руководство на сайте php.net и двадцать лет частовстречаемых вопросов. Что бы вы ни делали, кто-то сталкивался с этой проблемой и пытался ее решить за вас.<br/>
<br/>
У Node.js есть хорошая документация, но технология довольно молода, поэтому и ответов на форумах, будет значительно меньше.<br/>
<br/>
<h4>Оценка судей — <b>PHP 2:0 Node.js</b> </h4><br/>
<ul>
<li>Бруно: <i>промолчал</i> </li>
<li>Джеймс: Я согласен. Node.js более молодая технология, поэтому сейчас с поддержкой и документацией хуже. Эта проблема, однако, становится всё менее и менее серьёзной по мере взросления Node.<br/>
</li>
</ul><br/>
<h4>Третий раунд: синтаксис языка</h4><br/>
В отличие от некоторых языков и фреймворков, PHP не заставит вас работать определенным образом, и растет вместе с вами. Вы можете писать свои маленькие программы на простых функциях PHP4, и они будут отличаться своей красотой от MVC PHP 5+. Однако в таком случае, ваш код может быть хаотичным, вы начнете писать лучший код только с пониманием некоторых вещей. <br/>
<br/>
Синтаксис PHP изменялся с выходом новых версий, из-за чего была проведена работа по обратной совместимости. Вы можете легко перенести код с PHP4 на PHP5. Однако, в следствии такого подхода, в PHP образовался беспорядок (каша). <br/>
<br/>
Например, как вы подсчитать количество символов в строке? <br/>
<br/>
 — count()? str_len()? strlen()? mb_strlen()? <br/>
<br/>
Вы найдете в документации для этого несколько функции, но на самом деле, все просто. Вообще, в PHP много функций, которые работают одинаково, попробуйте написать несколько строк кода, не посоветовавшись с наставником.<br/>
<br/>
<pre><code class="php">&lt;?php
        $str = \'Hello world\'; 
	$size_1 = count($str);
	$size_2 = strlen($str); // верная функция

	$len = [$size_1, $size_2];
	print_r($len);
?&gt;
</code></pre><br/>
C JavaScript все иначе:<br/>
<br/>
<pre><code class="javascript">    var len = (\'Hello world\').length; 
    console.log(len);
</code></pre><br/>
Мы видим, что JavaScript в тоже время является сравнительно четкий, имея несколько основных тенденций. Его объектно-прототипная модель привлекает разработчиков, и кажется, что синтаксис довольно легкий, но это не так. Вы найдете критику о математических ошибках (0,1 + 0,2 != 0,3) и динамической типизации (\'4\' + 2 == \'42\' and \'4\' — 2 == 2). Но эти ситуации редко вызывают проблемы, и все языки имеют особенности.<br/>
<br/>
PHP имеет множество преимуществ, однако Node.js выигрывает по некоторым причинам:<br/>
<br/>
1. JavaScript кажется самым непонятным языком в мире, но как только вы улавливаете его концепцию, остальные языки становятся громоздкими по сравнению с ним.<br/>
2. JavaScript выглядит минимальнее, чем PHP, вам не нужно бороться с тем же UTF-8. <br/>
3. Full-stack разработчики могут писать код на JavaScript как на стороне клиента, так и на стороне сервера. Вам больше не нужно переключаться между технологиями.<br/>
4. Изучая JavaScript, вам хочется больше и чаще писать на этом языке, про PHP такого нельзя сказать.<br/>
<br/>
<h4>Оценка судей — <b>PHP 2:1 Node.js</b></h4><br/>
<ul>
<li>Бруно: Я категорически не согласен с этой точкой. Хотя PHP имеет свои особенности, многие из них были исправлены в последнее время, и многие странности удалены в новейших версиях. С другой стороны, точно такое же есть и в мире JS. Что касаемо серверной части, то тут я тоже не согласен. Клиентская сторона и серверная это разные вещи, и вам в любом случае, придется переключать свой мозг, на сервере такой же свой синтаксис, если мы пишем на Node.js, ежели мы пишем JavaScript-код для браузера. Поработав с JS и PHP, в свое время, первое мне нравится меньше и меньше, хотя это чисто личные предпочтения.</li>
<li>Джеймс: Я люблю JavaScript. Я знаю, она имеет свои причуды, и я знаю, что есть несколько подводных камней, но ECMAScript 2015 года исправляет многое, а добавляя интересные новые функции в язык. JavaScript является одновременно мощным и гибким, и может вместить много различных стилей программирования. В отличие от PHP, я люблю писать на JavaScript. Node.js выигрывает в этом раунде. <br/>
</li>
</ul><br/>
<br/>
<h4>Четвертый раунд: инструменты разработчика</h4><br/>
Обе технологии имеют хороший выбор редакторов, интегрированных сред разработки, отладчиков, валидаторов и других инструментов. Тут можно дать ничью, но все же Node.js имеет прекрасный инструмент, npm — менеджер пакетов, c его помощью можно управлять модулями и зависимостями. <br/>
<br/>
У PHP есть свой менеджер пакетов, разработанный под влиянием npm — Composer. Однако, ежели npm встроен по умолчанию, тот composer придется встраивать самостоятельно. Благодяря npm широкое распространение получили Gulp, Grunt — системы сборки front-end проектов. <br/>
<br/>
<h4> Оценка судей — <b>PHP 2:2 Node.js</b> </h4><br/>
<ul>
<li>Бруно: В то время как composer был первоначально вдохновлен npm, то теперь он даже лучше, чем npm. Composer не повредить вашу систему, если вы хотите установить две версии одной и того же библиотеки, в отличие от npm. Также в отличие от npm, composer может установить рекурсивные зависимости, в то время как npm просто не можете сделать. Npm также имеет совершенно ужасные сообщения об ошибках, которые называются «дружественными». Наконец, npm не особо работает с Vagrant, и тем самым препятствует вам начать работу должным образом, не говоря уже о том, что они не обращают внимания на желания своих пользователей. Присутствовала ошибка, которая была открыта в течение многих лет, из-за чего пользователям это было не пригодно на Windows — вряд ли это маленькая пользовательская база. PHP имеет свою долю ошибок, конечно, тоже глупых, но те не отталкивали целые ОС в течение многих лет.</li>
<li>Джеймс: Я люблю npm. Его легко использовать, и есть тысячи пакетов, доступные для почти любой необходимости. Мне также нравится тот факт, что npm позволяет выбрать между глобальной и локальной установки пакетов (в отличие от таких языков, как Ruby, где это стандарт для ваших драгоценных камней). Такие инструменты, как bower и grunt имеют постоянное место в моей работе, и увеличили мою производительность во много раз.<br/>
</li>
</ul><br/>
<br/>
<h4>Пятый раунд: среда</h4><br/>
Где могут быть использованы эти технологии. Как их развернуть? Какими платформами поддерживаются? Веб-разработчикам часто нужно создавать приложения, которые только относятся к web, например, разработка онлайн-сервиса, сценарии преобразования данных и т.д.<br/>
<br/>
На PHP вы можете разрабывать десктопные приложения или консольные утилиты, но в основном PHP нужен на стороне сервера и редко выходит за пределы этой границы. <br/>
<br/>
Несколько лет назад, JavaScript использовался исключительно для браузера. С приходом Node.js вы можете писать десктопные и мобильные приложения, а также можно программировать и микроконтроллеры. Node.js расширил границы JavaScript.<br/>
<br/>
<h4>Оценка судей — <b>PHP 2:3 Node.js</b></h4><br/>
<ul>
<li>Бруно: Ну, во-первых, мы сравниваем PHP с Node.js, а не PHP с JS. Во-вторых, мы сравниваем языки и среды, где они могут работать. Сказать, что обезьяна лучше, чем рыба, потому что рыбе не удалось подняться на дерево — это просто глупо. Но и обезьяны, и рыба может плавать, так что давайте сравнивать, насколько хорошо они это делают.</li>
<li>Джеймс: Несколько особенностей, которые делают Node.js так популярны (скорость, масштабируемость, совместимость с JSON, низкое использование ресурсов), позволяют использовать его для многих других видов применения, например, питающих разработке микроконтроллеров (IoT). Я имею в виду, кто не любит роботов?<br/>
</li>
</ul><br/>
<br/>
<h4>Шестой раунд: интеграция</h4><br/>
Ваши технологии разработки будут ограничены, если только они не могут интегрироваться с базами данных и драйверами. PHP сильна в этой области. Развитие было в течение многих лет, и его расширения системы позволяют прямую работать с любым хостом при помощи API.<br/>
<br/>
Node.js догоняет быстро, но вы можете изрядно попотеть, чтобы найти современные компоненты интеграции для старых вещей.<br/>
<br/>
<h4>Оценка судей — <b>PHP 3:4 Node.js</b> </h4><br/>
<ul>
<li>Бруно: Тут я дам ничью. PHP имеет возрастное преимущество, давая ему больше возможностей, но и тут можно было пострадать, от некоторых устаревших интегрированных вещей, например, расширение MySQL, от которого, наконец, сумели избавиться в PHP7.</li>
<li>Джеймс: Не уверен, что я согласен с этим. Я бы надеялся на примере «старых, менее популярных в технологии вещами». Один из главных плюсов Node.js — он понимает JSON. JSON является, вероятно, самым важным форматом обмена данных в Интернете, или взаимодействия с NoSQL базами данных. Когда вы работаете с Node.js, данные могут поступать аккуратно слоями без необходимости переформатирования. Вы имеете один синтаксис при общении с базой данных.<br/>
</li>
</ul><br/>
<h4>Седьмой раунд: хостинг и развертывание</h4><br/>
Как легко разворачиваются новенький приложения на настоящем веб-сервере? Тут еще одна чистая победа PHP. Любой хостинг интернета поддерживает PHP. Вы можете получить MySQL базу данных по выгодной цене. Тут PHP значительно проще песочницы (локального сервера) и вы будете точно уведомлены, какие PHP расширения отключены, а какие нет.<br/>
<br/>
Node.js совсем другой зверь, и он может работать на стороне сервера постоянно, без разрыва связи. Для этого, вам придется искать специализированные хостинги. Вам потребуется виртуальное облако (VDS/VPS, серверная среда, с полным доступом). К сожалению, такое могут себе позволить не все хостеры, поэтому и цены будут соответствующие.<br/>
<br/>
<h4>Оценка судей — <b>PHP 4:4 Node.js</b></h4><br/>
<ul>
<li>Бруно: <i>молчит</i></li>
<li>Джеймс: В будущем, Node.js многое наверстает. Как правило, веб-сервер PHP распространяется вместе с MySQL. Чтобы увидеть какой-то php код, все, что вам надо сделать, это создать файл с расширением .php и засунуть между &lt;?php и ?&gt; код, загрузить файл на сервер, указать в адресной строке, путь к этому файлу. То же самое нельзя сказать про Node.js. Есть, конечно, много вариантов хостинга для Node.js, но они неизменно требуют более детальной настройки и доступа к командной строке, которая потенциально отталкивает начинающих.<br/>
</li>
</ul><br/>
<h4>Восьмой раунд: производительность</h4><br/>
PHP не сутулиться и есть реальные проекты, и варианты, которые позволяют PHP работать быстрее. Даже самый требовательный разработчик PHP редко беспокоится о скорости, но производительность Node.js, как правило, лучше. Конечно, производительность в значительной степени является следствием опыта и командной разработки, однако, Node.js имеет несколько преимуществ:<br/>
<br/>
1. Меньше зависимостей<br/>
Все запросы к приложению PHP должны быть направлены на веб-сервер, который запускает интерпретатор PHP, который обрабатывает код и отдает его. Node.js не нужно так много зависимостей, и, хотя вы почти наверняка используете фреймворк на сервере, такой как express, он совсем легкий и управляет частью вашего приложения.<br/>
<br/>
2. Быстрый интерпретатор<br/>
Node.js меньше и проворнее, чем РНР. Это связано с наследием Google, который сделал огромный вклад в производительность JavaScript движка — V8.<br/>
<br/>
3. Приложения работают постоянно<br/>
РНР выполняет обычную клиент-серверную модель. Каждый запрос страницы инициирует приложение, загрузка параметров подключения к базе данных, извлечение информации и отображения HTML-кода. В Node.js приложение постоянно работает и его нужно инициализировать только один раз. Например, можно создать один объект подключения к базе данных, которая используется повторно при новом запросе. Правда, есть способы, реализации такого поведения и на PHP с использованием специальных систем, таких как memcached, но это не стандартная функция языка.<br/>
<br/>
4. Событийный, неблокирующий поток ввода/вывода<br/>
PHP и большинство других серверных языков используют очевидную модель блокировки. Когда вы делаете запрос на извлечение информации из базы данных, запрос выполнит и завершит процесс, прежде чем перейдет к следующему оператору. В Node.js все иначе. В Node.js не нужно ждать. Вместо этого можно создать функцию обратного вызова, которая, прослушивая процесс, выполняется после того, как действие завершится.<br/>
<br/>
Хоть Node.js приложения заметно быстрее, чем PHP тут есть и свои подводные камни.<br/>
<br/>
Node.js / JavaScript работает в одном потоке, а большинство веб-серверов многопоточные и обрабатывают запросы параллельно. Написание асинхронного кода является сложным и несет свои собственные проблемы. <br/>
<br/>
<h4>Оценка судей — <b>PHP 4:5 Node.js</b></h4><br/>
<ul>
<li>Бруно: Заблуждения предостаточно. Во-первых, обсуждения производительности спорные. Любой прирост производительности зависят исключительно от опыта разработчиков и типа приложения. Но даже если это сообщение не является убедительным, вот некоторые из моих собственных аргументов: PHP вполне работает с многопоточным встроенным веб-сервером, это позволяет не использовать внешний сервер полностью, но это не рекомендуется (пока что). Есть также супер быстрые серверы, такие как Nginx, которые делают весь процесс запуска PHP и делегирования запросов к нему незаметными. Такие проекты, как HHVM и Appserver добавляют мощные асинхронные и многопоточные аспекты, сам PHP7 с обновлением версии станет намного мощнее прежнего. Да php приложение получает только статику, и живет всего лишь один раз в запрос, однако и это можно обойти: memcached, ajax. Серверные JS приложения работают в одном запросе по умолчанию. PHP же нужно постоянно делать запросы к странице, чтобы обновить ее, но более того — жизнь одного запроса является только преимуществом, так как мы делаем запрос снова на PHP, наше приложение восстанавливается (каждый раз при запросе), когда оно используется, тем самым мы избегаем проблемы с памятью, очисткой мусора. </li>
<li>Джеймс: Node.js распространяется как платформа с высокой производительностью, низкой латентности приложений. Благодаря неблокирующему механизму ввода / вывода и технологии Google Chrome V8, Node.js стал синонимом слов «быстрый» и «масштабируемый». Есть многочисленные истории о том, как Node.js принес серьезные прирост производительности в компании и произвел повышение производительности самих разработчика. Я рад такому, но опять же, это спорный момент.<br/>
</li>
</ul><br/>
<br/>
<h4>Девятый раунд: страсть программирования</h4><br/>
Это немного сложно сравнивать, но относительно немногие разработчики PHP увлечены самим языком. Когда в последний раз вы читали статью по PHP или смотрели презентацию, которая пленила публику? Возможно, все, что было сказано? Может быть, есть менее увлекательным? Может быть, вы не смотрите в нужных местах? Есть некоторые интересные особенности, которые появились совсем недавно, например, появление — PHP7, но все же эта технология топталась в течение нескольких лет. Это сказалось на самом языке, многие разработчики стали ругать PHP.<br/>
<br/>
JavaScript делит сообщество. Есть те, кто любит его и тех, кто ненавидит его, немногие разработчики сидят на заборе. Тем не менее, ответы по Node.js были в значительной степени положительные и технология находится на гребне волны. Это отчасти потому, что она новая, на данный момент, Node.js выигрывает этот раунд.<br/>
<br/>
<h4>Оценка судей — <b>PHP 4:6 Node.js</b></h4><br/>
<ul>
<li>Бруно: Вы, безусловно, смотрите не в тех местах. PHP-сообщество невероятно страстное и очень активно. Есть более 20 крупных конференций в год, а некоторые удивительные темы получают свои обсуждения. Появиление HHVM и PHP7 тоже дает о себе знать. Кроме того, я хотел бы сказать, что это интересно, когда видишь, что разработчики Node.js по-прежнему не научились менять номера версий (версия v0.12.5 на момент написания статьи), даже после 6 лет развития. Многие незрелости, в сочетании с критическими, но игнорируемыми старыми ошибками, могут отталкивать целые операционных систем, все это является то, что серьезный разработчик будет думать дважды. Мне не нравится Node.js. Моz неприязнь основывается на негативном опыте в основном при работе с npm. Возможно все измениться в будущем, но сейчас, я полон страха и отчаяния, когда мне предстоит еще раз использовать Node.js. У всех нас есть свои предпочтения, но важно, чтобы все это оставалось объективным, нам нужно выбирать правильный инструмент для своей работы. Также важно признать, что иногда выбор правильного инструмента влечет за собой неправильный выбор другого. Не слушайте никого. Попробуйте сами — посмотрите, что работает, выясните, что вы чувствуете. В конечном счете, именно то, что вы делаете заставляет вас чувствовать себя продуктивным и это является лучшим выбором, а не тот выбор, который дает вам миллисекунды дополнительного прироста.</li>
<li>Джеймс: В сообществе Node.js очень жарко. Существует много открытий в Node.js-мире. Несмотря на то, моя страсть является субъективной, я рад, что Node.js выиграл этот раунд.<br/>
</li>
</ul><br/>
<h4>Деcятый раунд: будущее</h4><br/>
Это не особо важно, какой язык вы используете на стороне сервера, он все равно будет продолжать работать, даже если проект заброшен. Многие продолжают использовать PHP. Это безопасная ставка и ее поддержка выглядит уверенной еще двадцать лет.<br/>
При этом мы знаем, что восхождение Node.js было быстрым. Современный подход к развитию очевиден тем, что использует тот же синтаксис, что и на клиентской стороне. JavaScript поддерживает HTML5, веб-сокеты. Node.js неизбежно отнимает долю на рынке, но PHP, я сомневаюсь, что будет обгонять. Обе технологии имеют большое будущее. Я заявляю, этот раунд заканчивается ничьей.<br/>
<br/>
<h4>Оценка судей — <b>PHP 5:7 Node.js</b></h4><br/>
<ul>
<li>Бруно: <i>молчание</i>.</li>
<li>Джеймс: Ничья была справедливым результатом этого раунда. Node.js является восходящей звездой, но массивный PHP ему не свергнуть. В завершение можно добавить, если ваш инструмент кажется молотком, то каждая проблема кажется гвоздем. Node.js не идеально подходит для каждого сценария, и в самом деле лучше много раз подумать, когда и где, имеет смысл использовать его. Тем не менее, там где Node.js плох, это даже очень хорошо. Вы сможете сделать осознанный выбор и выбрать лучший инструмент для своей работы.<br/>
</li>
</ul><br/>
<h4><b>Абсолютный победитель</b></h4><br/>
Окончательный счет 5:7 в пользу Node.js. Node.js имеет крутую кривую обучения и не является идеальным для начинающих разработчиков, но он все же выигрывает. Просто. Если вы грамотный JavaScript-программист, который любит свой язык, Node.js не разочарует вас. Вы почувствуете себя свежее и получите освободительный опыт веб-разработки. Но не стоит сбрасывать PHP со счетов. PHP жив, и есть мало оснований ставить подножку PHP, из-за того, что это выглядит модным. PHP проще изучить, вы сможете овладеть профессиональными приемы программирования, главное практика. PHP очень легко развернуть на сервере. Даже упертые Node.js-разработчики должны использовать PHP для простых сайтов и приложений.<br/>
<br/>
Мой совет: оценить варианты и выбрать язык, основанный на ваших требованиях. Это гораздо более практично, чем полагаться на «за и против»!',
                'views' => mt_rand(251, 1502),
                'description' => 'Это перевод статьи Крэга Баклера (Craig Buckler) «SitePoint Smackdown: PHP vs Node.js» и судейских решений Бруно Шкворца и Джеймса Хиббарда (Bruno Škvorc, James Hibbard) статьи Крэга Баклера.'
            ],

            [
                'category_id' => 2,
                'author_id' => 1,
                'title' => 'Блокчейн за 200 строк кода: пример простой реализации на JavaScript',
                'image' => 'blog-4.jpg',
                'text' => '<h3>Структура блока</h3><p>Первый шаг — определить элементы, которые должен содержать блок. Для простоты включим только самое необходимое: индекс (index), временную метку (timestamp), данные (data), хеш и хеш предыдущего блока, который нужно записывать, чтобы сохранить структурную целостность цепи.</p><p><a class="lightbox" href="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-pbyFH4U5sO27UE1EjnImoA.png"><img src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-pbyFH4U5sO27UE1EjnImoA.png" alt="" width="817" height="191" ><noscript><img
class="aligncenter size-full wp-image-31447" src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-pbyFH4U5sO27UE1EjnImoA.png" alt="" width="817" height="191" srcset="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-pbyFH4U5sO27UE1EjnImoA.png 817w, https://cdn.tproger.ru/wp-content/uploads/2017/03/1-pbyFH4U5sO27UE1EjnImoA-300x70.png 300w" sizes="(max-width: 817px) 100vw, 817px" /></noscript></a></p><pre class="line-numbers"><code class="language-clike">class Block {
    constructor(index, previousHash, timestamp, data, hash) {
        this.index = index;
        this.previousHash = previousHash.toString();
        this.timestamp = timestamp;
        this.data = data;
        this.hash = hash.toString();
    }
}</code></pre><h3>Хеш блока</h3><p>Хеширование блоков нужно для сохранения целостности данных. В нашем примере для этого применяется алгоритм <a href="https://ru.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener nofollow noreferrer" data-wpel-link="external">SHA-256</a>. Этот вид хеша не имеет отношения к майнингу, так как мы в данном случае не реализуем защиту с помощью <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE_%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F_%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B" target="_blank" rel="noopener nofollow noreferrer" data-wpel-link="external">доказательства выполнения работы</a>.</p><pre class="line-numbers"><code class="language-clike">var calculateHash = (index, previousHash, timestamp, data) =&gt; {
    return CryptoJS.SHA256(index + previousHash + timestamp + data).toString();
};</code></pre><h3>Генерируем блок</h3><p>Для генерации блока нам нужно знать хеш предыдущего блока и внести остальные элементы, которые мы обозначили в структуре блока. Данные предоставляются конечным пользователем.</p><pre class="line-numbers"><code class="language-clike">var generateNextBlock = (blockData) =&gt; {
    var previousBlock = getLatestBlock();
    var nextIndex = previousBlock.index + 1;
    var nextTimestamp = new Date().getTime() / 1000;
    var nextHash = calculateHash(nextIndex, previousBlock.hash, nextTimestamp, blockData);
    return new Block(nextIndex, previousBlock.hash, nextTimestamp, blockData, nextHash);
};</code></pre><h3>Хранение блоков</h3><p>Для хранения блокчейна используем массив. Первый блок всегда является жестко заданным «генезис-блоком».</p><pre class="line-numbers"><code class="language-clike">var getGenesisBlock = () =&gt; {
    return new Block(0, "0", 1465154705, "my genesis block!!", "816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7");
};

var blockchain = [getGenesisBlock()];</code></pre><h3>Подтверждаем целостность блоков</h3><p>Мы всегда должны иметь возможность подтвердить целостность блока или цепи. Особенно когда получаем новые блоки с других узлов и должны решить, принимать их или нет.</p><pre class="line-numbers"><code class="language-clike">var isValidNewBlock = (newBlock, previousBlock) =&gt; {
    if (previousBlock.index + 1 !== newBlock.index) {
        console.log(\'неверный индекс\');
        return false;
    } else if (previousBlock.hash !== newBlock.previousHash) {
        console.log(\'неверный хеш предыдущего блока\');
        return false;
    } else if (calculateHashForBlock(newBlock) !== newBlock.hash) {
        console.log(\'неверный хеш: \' + calculateHashForBlock(newBlock) + \' \' + newBlock.hash);
        return false;
    }
    return true;
};</code></pre><h3>Выбираем самую длинную цепь</h3><p>Последовательность блоков в цепи всегда должна быть задана явно, поэтому в случае конфликтов (например, на двух узлах одновременно сгенерированы блоки под одним и тем же номером) мы выбираем цепь, в которой содержится большее количество блоков.</p><p><a class="lightbox" href="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-KM7WYPiZwxyfDL6Eb66QIg.png"><img  src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-KM7WYPiZwxyfDL6Eb66QIg.png" alt="" width="820" height="450" ><noscript><img
class="aligncenter size-full wp-image-31454" src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-KM7WYPiZwxyfDL6Eb66QIg.png" alt="" width="820" height="450" srcset="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-KM7WYPiZwxyfDL6Eb66QIg.png 820w, https://cdn.tproger.ru/wp-content/uploads/2017/03/1-KM7WYPiZwxyfDL6Eb66QIg-300x165.png 300w" sizes="(max-width: 820px) 100vw, 820px" /></noscript></a></p><pre class="line-numbers"><code class="language-clike">var replaceChain = (newBlocks) =&gt; {
    if (isValidChain(newBlocks) &amp;&amp; newBlocks.length &gt; blockchain.length) {
        console.log(\'Принятый блокчейн является валидным. Происходит замена текущего блокчейна на принятый\');
        blockchain = newBlocks;
        broadcast(responseLatestMsg());
    } else {
        console.log(\'Принятый блокчейн не является валидным\');
    }
};</code></pre><h3>Сообщение с другими узлами сети</h3><p>Неотъемлемая часть узла — обмен данными с другими узлами. Следующие правила используются для поддержания синхронизации в сети:</p><ul><li>Когда узел генерирует новый блок, он сообщает об этом в сеть;</li><li>Когда узел подсоединяется к новому пиру, он запрашивает информацию о последнем сгенерированном блоке;</li><li>Когда узел сталкивается с блоком, у которого индекс больше, чем у него, он либо добавляет блок к своей цепи, либо запрашивает информацию о полной цепи.</li></ul><p>Автоматический поиск пиров не осуществляется, все ссылки добавляются в ручную.<br />
<a class="lightbox" href="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-sz2iVHdWBdtwNl3npeLddQ.png"><img src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-sz2iVHdWBdtwNl3npeLddQ.png" alt="" width="959" height="354"><noscript><img
class="aligncenter size-full wp-image-31481" src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-sz2iVHdWBdtwNl3npeLddQ.png" alt="" width="959" height="354" srcset="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-sz2iVHdWBdtwNl3npeLddQ.png 959w, https://cdn.tproger.ru/wp-content/uploads/2017/03/1-sz2iVHdWBdtwNl3npeLddQ-300x111.png 300w" sizes="(max-width: 959px) 100vw, 959px" /></noscript></a></p><h3>Контроль за узлом</h3><p>Пользователь должен иметь возможность каким-то образом контролировать узел, что решается с помощью установки сервера HTTP. При взаимодействии с узлом доступны следующие функции:</p><ul><li>Вывести список всех блоков;</li><li>Создать новый блок с пользовательским контентом;</li><li>Вывести списком или добавить пиры.</li></ul><p>Самый прямой путь взаимодействия — с помощью <a href="https://ru.wikipedia.org/wiki/CURL" target="_blank" rel="noopener nofollow noreferrer" data-wpel-link="external">cURL</a>:</p><pre class="line-numbers"><code class="language-bash"># вывести список всех блоков на узле
curl http://localhost:3001/blocks</code></pre><h3>Архитектура</h3><p>Стоит заметить, что узел обращается к двум веб серверам: к HTTP для пользовательского контроля за узлом и к Websocket HTTP для установки соединения P2P между узлами.<br />
<a class="lightbox" href="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-BMc5ZcrrH1IRtAx1dOG7DQ.png"><img src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-BMc5ZcrrH1IRtAx1dOG7DQ.png" alt="" width="389" height="176" ><noscript><img
class="aligncenter size-full wp-image-31456" src="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-BMc5ZcrrH1IRtAx1dOG7DQ.png" alt="" width="389" height="176" srcset="https://cdn.tproger.ru/wp-content/uploads/2017/03/1-BMc5ZcrrH1IRtAx1dOG7DQ.png 389w, https://cdn.tproger.ru/wp-content/uploads/2017/03/1-BMc5ZcrrH1IRtAx1dOG7DQ-300x136.png 300w" sizes="(max-width: 389px) 100vw, 389px" /></noscript></a><br />
Готово! Мы реализовали простой небольшой блокчейн. Со всеми деталями проекта можно <a href="https://github.com/lhartikk/naivechain" target="_blank" rel="noopener nofollow noreferrer" data-wpel-link="external">ознакомиться</a> в репозитории автора на GitHub.</p>',
                'views' => mt_rand(279, 2047),
                'description' => 'Понять концепцию блокчейна (англ. block chain, цепочка блоков транзакций) довольно просто: это распределенная (т.е. размещенная не на одном компьютере, а на различных устройствах компьютерной сети) база данных, которая поддерживает постоянно растущий организованный список записей.'
            ],

            [
                'category_id' => 6,
                'author_id' => 1,
                'title' => 'PHP 7.1.1 FPM vs Node.js 7.4.0 в качестве web backend сервера',
                'image' => 'blog-5.jpg',
                'text' => '<b>Конфигурация сервера:</b><br/>
<br/>
Простой VDS — 1 ядро процессора 2ГГц, 1Гб оперативы, 10Гб SSD.<br/>
ОС: Debian 8.6.<br/>
Так же произведены базовые настройки ядра, чтобы сервер в принципе мог обрабатывать большое кол-во соединений.<br/>
<br/>
<b>Испытуемые:</b><br/>
<br/>
 — PHP 7.1.1 FPM<br/>
 — Node.js 7.4.0<br/>
<br/>
<b>Первый этап:</b><br/>
<br/>
Тут операции, которые в основном использует backend. А именно: склеивание строк, сетевой ввод-вывод, арифметика и работа с массивами.<br/>
<a name="habracut"></a><br/>
Код для Node.js:<br/>
<br/>
<pre><code class="javascript">var fs = require(\'fs\');
var mysql = require(\'mysql2\');

console.time(\'Node.js \' + process.version + \': склеивание строк 1000000 раз\');
var str = \'\';
for (var i = 0; i &lt; 1000000; i++) {
	str += \'s\';
}
console.timeEnd(\'Node.js \' + process.version + \': склеивание строк 1000000 раз\');


console.time(\'Node.js \' + process.version + \': сложение чисел 1000000 раз\');
var count = 0;
for (var i = 0; i &lt; 1000000; i++) {
	count++;
}
console.timeEnd(\'Node.js \' + process.version + \': сложение чисел 1000000 раз\');


console.time(\'Node.js \' + process.version + \': наполнение простого массива 1000000 раз\');
var array = [];
for (var i = 0; i &lt; 1000000; i++) {
	array.push(\'s\');
}
console.timeEnd(\'Node.js \' + process.version + \': наполнение простого массива 1000000 раз\');


console.time(\'Node.js \' + process.version + \': наполнение ассоциативного массива 1000000 раз\');
var array = {};
for (var i = 0; i &lt; 1000000; i++) {
	array[\'s\' + i] = \'s\';
}
console.timeEnd(\'Node.js \' + process.version + \': наполнение ассоциативного массива 1000000 раз\');


console.time(\'Node.js \' + process.version + \': чтение файла 100 раз\');
var content;
for (var i = 0; i &lt; 100; i++) {
    content = fs.readFileSync(\'./someFile.txt\');
}
console.timeEnd(\'Node.js \' + process.version + \': чтение файла 100 раз\');


console.time(\'Node.js \' + process.version + \': mysql query (SELECT NOW()) 100 раз\');
// create the connection to database
var connection = mysql.createConnection({host:\'localhost\', user: \'root\', database: \'test\', password: \'password\'});

function promiseQuery(query) {
    return new Promise((resolve, reject) =&gt; {
            connection.query(query, function (err, results, fields) {
            resolve({err, results, fields});
        });
	});
}
for (var i = 0; i &lt; 100; i++) {
    var a = promiseQuery(\'SELECT NOW()\');
    a.then(({err, results, fields}) =&gt; {
        //console.log(results);
    });
}
console.timeEnd(\'Node.js \' + process.version + \': mysql query (SELECT NOW()) 100 раз\');
connection.end();
</code></pre><br/>
Код для PHP:<br/>
<br/>
<pre><code class="php">&lt;?php
$phpVersion = &quot;v&quot; . explode(\'-\', PHP_VERSION)[0];


$start = microtime(1);
$str = \'\';
for ($i = 0; $i &lt; 1000000; $i++) {
	$str .= \'s\';
}

echo &quot;PHP $phpVersion: склеивание строк 1000000 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;


$start = microtime(1);
$count = 0;
for ($i = 0; $i &lt; 1000000; $i++) {
	$count++;
}

echo &quot;PHP $phpVersion: сложение чисел 1000000 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;



$start = microtime(1);
$array = array();
for ($i = 0; $i &lt; 1000000; $i++) {
	$array[] = \'s\';
}

echo &quot;PHP $phpVersion: наполнение простого массива 1000000 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;


$start = microtime(1);
$array = array();
for ($i = 0; $i &lt; 1000000; $i++) {
	$array[&quot;s&quot; . $i] = \'s\';
}

echo &quot;PHP $phpVersion: наполнение ассоциативного массива 1000000 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;


$start = microtime(1);
for ($i = 0; $i &lt; 100; $i++) {
    $fp = fopen(&quot;./someFile.txt&quot;, &quot;r&quot;);
    $content = fread($fp, filesize(&quot;./someFile.txt&quot;));
    fclose($fp);
}

echo &quot;PHP $phpVersion: чтение файла 100 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;


$start = microtime(1);
$mysql = new mysqli(\'localhost\', \'root\', \'password\', \'test\');
for ($i = 0; $i &lt; 100; $i++) {
	$res = $mysql-&gt;query(&quot;SELECT NOW() as `now`&quot;);
	$now = $res-&gt;fetch_assoc()[\'now\'];
}

echo &quot;PHP $phpVersion: mysql query (SELECT NOW()) 100 раз: &quot; . round((microtime(1) - $start) * 1000, 3) . &quot;ms \n&quot;;
</code></pre><br/>
<b>Результаты:</b><br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/1d8/4d6/d4a/1d84d6d4a2271fe5b11840df2f772741.jpg" alt="image"/><br/>
<br/>
Как видно, PHP выигрывает по всем пунктам, кроме операции сложения.<br/>
<br/>
<b>Второй этап:</b><br/>
<br/>
Нагрузочное тестирование «Hello world». Nginx 11.7 + PHP 7.1.1 FPM vs Node.js. 1000 запросов в 1000 потоков. #ab -n 1000 -c 1000…<br/>
<br/>
Код PHP:<br/>
<br/>
<pre><code class="php">&lt;?php
echo &quot;Hello world&quot;;
?&gt;
</code></pre><br/>
Код Node.js:<br/>
<br/>
<pre><code class="javascript">const http = require(\'http\');

const hostname = \'127.0.0.1\';
const port = 3000;

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader(\'Content-Type\', \'text/plain\');
  res.end(\'Hello World\');
});

server.listen(port, hostname, () =&gt; {
  console.log(`Server running at http://${hostname}:${port}/`);
});
</code></pre><br/>
<b>Результаты</b><br/>
<br/>
Прогнал по 10 тестов для PHP и для Node.js и выбрал лучшие результаты у обоих.<br/>
<br/>
Node.js:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/d5a/abd/21c/d5aabd21c9f6b6be0f94a34ed737cdee.jpg" alt="image"/><br/>
<br/>
PHP:<br/>
<br/>
<img src="https://habrastorage.org/getpro/habr/post_images/ccc/08f/84d/ccc08f84d2fe44b13b96943bf5f80e2a.jpg" alt="image"/><br/>
<br/>
Как видим и тут PHP выигрывает на 23% или на 628 запросов в секунду. Много это или мало судить вам.<br/>
<br/>
Делитесь в комментах своими мыслями по этому поводу.',
                'views' => mt_rand(472, 4840),
                'description' => 'Всем привет, решил поделиться с вами результатами синтетического теста производительности свежих версий PHP и Node.js.'
            ],
        ];

        foreach ($posts as $post) {
            DB::table('posts')->insert([
                'category_id' => $post['category_id'],
                'author_id' => $post['author_id'],
                'title' => $post['title'],
                'image' => $post['image'],
                'text' => $post['text'],
                'views' => $post['views'],
                'description' => $post['description'],
                'created_at' => Carbon::now(),
                'updated_at' => Carbon::now()
            ]);
        }
    }
}
